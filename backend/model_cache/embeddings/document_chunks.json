["MODULE 1\nIntroduction to Operating system\nDownloaded from Ktunotes.in\n\n\nCONTENTS\n\u2022 Introduction: Operating system overview \u2013 \nOperations, Functions, Service \u2013 System calls,\n\u2022 Types \u2013 Operating System structure - Simple \nstructure, Layered approach, Microkernel, \nModules\u2013 System boot process\nDownloaded from Ktunotes.in\n\n\nIntroduction to Operating system\nAn operating system is a program that manages a \ncomputer\u2019s hardware.\nAn Operating System is a program that acts as an \nintermediary between a user of a computer and the \ncomputer hardware.\nDownloaded from Ktunotes.in\n\n\nFour Components of a Computer System \n(Computer System Structure)\nDownloaded from Ktunotes.in\n\n\nComputer System Structure\n\u2022 Computer system can be divided into four components\n\u2013 Hardware \u2013 provides basic computing resources\n\u2022 CPU, memory, I/O devices.\n\u2013 Operating system\n\u2022 Controls and coordinates use of hardware among various \napplications and users.\n\u2013 Application programs \u2013 define the ways in which the \nsystem resource", "\u2022 CPU, memory, I/O devices.\n\u2013 Operating system\n\u2022 Controls and coordinates use of hardware among various \napplications and users.\n\u2013 Application programs \u2013 define the ways in which the \nsystem resources are used to solve the computing problems \nof the users.\n\u2022 Word processors,  web browsers, database systems, video games\n\u2013 Users\n\u2022 People, machines, other computers\nDownloaded from Ktunotes.in\n\n\nApplication Soft wares are programs that help the user to perform specific task. \nEg: Word processors,  web browsers, database systems, video games\nSystem Software is a set of programs that control and manage the operations of \ncomputer hardware. It also helps application programs to execute correctly.\nDownloaded from Ktunotes.in\n\n\n\u2022 To understand ,fully the operating system's role, we explore \noperating systems from two viewpoints: \n\u2013 The user \n\u2013 The system.\nUser View:\nThe user's view of the computer varies according to the interface being \nused\n\u2022 Single user computers (e.g., PC, workstations).", "ating systems from two viewpoints: \n\u2013 The user \n\u2013 The system.\nUser View:\nThe user's view of the computer varies according to the interface being \nused\n\u2022 Single user computers (e.g., PC, workstations). Such systems are \ndesigned for one user to monopolize its resources. The goal is to \nmaximize the work (or play) that the user is performing. the operating \nsystem is designed mostly for ease of use and good performance. \n\u2022 Multi user computers (e.g.,  mainframes, computing servers). These \nusers share resources and may exchange information. The operating \nsystem in such cases is designed to maximize resource utilization -- to \nassure that all available CPU time, memory, and I/O are used \nefficiently and that no individual users takes more than their air share\nDownloaded from Ktunotes.in\n\n\nUser View (Cont.)\n\u2022 Handheld computers (e.g., smartphones and tablets).  The \nuser interface for mobile computers generally features a  \ntouch screen. The systems  are resource poor,  optimized for \nusa", "er View (Cont.)\n\u2022 Handheld computers (e.g., smartphones and tablets).  The \nuser interface for mobile computers generally features a  \ntouch screen. The systems  are resource poor,  optimized for \nusability and battery life.\n\u2022 Embedded computers (e.g., computers in home devices and \nautomobiles) The user interface may have numeric keypads \nand may turn indicator lights on or off to show status. The \noperating systems are designed primarily to run without user \nintervention.\nDownloaded from Ktunotes.in\n\n\nSystem View:\n\u2022 OS is a resource allocator\n\u2013 Manages all resources\n\u2013 Decides between conflicting requests for efficient \nand fair resource use\n\u2022 OS is a control program\n\u2013 Controls execution of programs to prevent errors \nand improper use of the computer\nDownloaded from Ktunotes.in\n\n\nOS goals:\n\u2013 Control/execute user/application programs.\n\u2013 Make the computer system convenient to use.\n\u2013 Ease the solving of user problems.\n\u2013 Use the computer hardware in an efficient manner.\nClick to add text\nDownloaded from Ktunotes.in", "plication programs.\n\u2013 Make the computer system convenient to use.\n\u2013 Ease the solving of user problems.\n\u2013 Use the computer hardware in an efficient manner.\nClick to add text\nDownloaded from Ktunotes.in\n\n\nFunctions of an Operating System\n\u2022 Process Management\n\u2022 Memory Management\n\u2022 Storage Management\n\u2022 I/O Management\n\u2022 Protection and Security\nDownloaded from Ktunotes.in\n\n\nProcess Management\n\u2022 A process is program in execution.\nEg: A word-processing program being run by an individual user \non a PC\n\u2022 A process needs certain resources to accomplish its task.\n\u2013 CPU time\n\u2013  memory\n\u2013  files\n\u2013  I/O devices. \n\u2022 These resources are either given to the process when it is \ncreated or allocated to it while it is running.\nDownloaded from Ktunotes.in\n\n\nProcess Management\n\u2022 The operating system is responsible for the following process \nmanagement activities : \n\u2013 Scheduling processes and threads on the CPUs\n\u2013  Creating and deleting both user and system processes\n\u2013  Suspending and resuming processes\n\u2013  Pro", "e for the following process \nmanagement activities : \n\u2013 Scheduling processes and threads on the CPUs\n\u2013  Creating and deleting both user and system processes\n\u2013  Suspending and resuming processes\n\u2013  Providing mechanisms for process synchronization\n\u2013  Providing mechanisms for process communication\nDownloaded from Ktunotes.in\n\n\nMemory Management\n\u2022 Main memory is the only large storage device that the CPU is \nable to address and access directly.\n\u2022 For a program to be executed, it must be mapped to absolute \naddresses and loaded into memory.\n\u2022 As the program executes, it accesses program instructions and \ndata from memory by generating these absolute addresses. \n\u2022 When the program terminates, its memory space is declared \navailable, and the next program can be loaded and executed.\n\u2022 To improve both the utilization of the CPU and the speed of \nthe computer\u2019s response to its users, general-purpose \ncomputers must keep several programs in memory, creating a \nneed for memory management.\nDownloaded from Ktunotes.in", "of the CPU and the speed of \nthe computer\u2019s response to its users, general-purpose \ncomputers must keep several programs in memory, creating a \nneed for memory management.\nDownloaded from Ktunotes.in\n\n\nMemory Management\n\u2022 The operating system is responsible for the following \nmemory management activities :\n\u2013  Keeping track of which parts of memory are \ncurrently being used and who is using them\n\u2013  Deciding which processes (or parts of processes) \nand data to move into and out of memory\n\u2013  Allocating and deallocating memory space as \nneeded\nDownloaded from Ktunotes.in\n\n\nStorage management-File-System Management\nFiles represent programs (both source and object forms) and data.\nData files may be numeric, alphabetic, alphanumeric, or binary.\nThe operating system is responsible for the following  file \nmanagement activities :\n\u2022 Creating and deleting files\n\u2022 Creating and deleting directories to organize files\n\u2022  Supporting primitives for manipulating files and directories\n\u2022  Mapping files o", "ng  file \nmanagement activities :\n\u2022 Creating and deleting files\n\u2022 Creating and deleting directories to organize files\n\u2022  Supporting primitives for manipulating files and directories\n\u2022  Mapping files onto secondary storage\n\u2022  Backing up files on stable (non-volatile) storage media\nDownloaded from Ktunotes.in\n\n\nStorage management-Mass Storage Management\n\u2022 Main memory is too small to accommodate all data and \nprograms, and because the data that it holds are lost when \npower is lost, the computer system must provide secondary \nstorage to back up main memory. \n\u2022 Most modern computer systems use disks as the principal on-\nline storage medium for both programs and data.\n\u2022 The operating system is responsible for the following \nactivities in connection with disk management:\n   \u2022 Free-space management\n   \u2022 Storage allocation\n   \u2022 Disk scheduling\nDownloaded from Ktunotes.in", "he operating system is responsible for the following \nactivities in connection with disk management:\n   \u2022 Free-space management\n   \u2022 Storage allocation\n   \u2022 Disk scheduling\nDownloaded from Ktunotes.in\n\n\nStorage management-Caching:\n\u2022 Information is normally kept in some storage system (such as \nmain memory).\n\u2022 As it is used, it is copied into a faster storage system ,the cache \non a temporary basis. \n\u2022 When we need a particular piece of information, we first \ncheck whether it is in the cache. If it is, we use the information \ndirectly from the cache. \n\u2022 If it is not, we use the information from the source, putting a \ncopy in the cache under the assumption that we will need it \nagain soon.\nDownloaded from Ktunotes.in\n\n\n Storage management-Caching: \nCache memory\u00a0is an extremely fast\u00a0memory\u00a0type that acts as a \nbuffer between\u00a0RAM\u00a0and the CPU. It holds frequently \nrequested data and instructions so that they are immediately \navailable to the CPU when needed.\u00a0Cache memory\u00a0is used to \nreduce", "pe that acts as a \nbuffer between\u00a0RAM\u00a0and the CPU. It holds frequently \nrequested data and instructions so that they are immediately \navailable to the CPU when needed.\u00a0Cache memory\u00a0is used to \nreduce the average time to access data from the Main\u00a0memory\nInstruction Cache\n\u2022 Most systems have an instruction cache to hold the instructions \nexpected to be executed next. \n\u2022 Without this cache, the CPU would have to wait several cycles \nwhile an instruction was fetched from main memory. \nData Cache\n\u2022 Most systems have one or more high-speed data caches in the \nmemory hierarchy.\nDownloaded from Ktunotes.in\n\n\nStorage management-Caching:\n\u2022 Because caches have limited size, cache management is an \nimportant design problem. \nDownloaded from Ktunotes.in\n\n\nStorage management-Caching:\n\u2022 In a hierarchical storage structure, the same data may appear \nin different levels of the storage system.\n\u2022  For example, suppose that an integer A that is to be \nincremented by 1 is located in file B, and file B resi", "storage structure, the same data may appear \nin different levels of the storage system.\n\u2022  For example, suppose that an integer A that is to be \nincremented by 1 is located in file B, and file B resides on \nmagnetic disk.\n\u2022 The increment operation proceeds by first issuing an I/O \noperation to copy the disk block on which A resides to main \nmemory. \n\u2022 This operation is followed by copying A to the cache and to an \ninternal register. \n\u2022 Thus, the copy of A appears in several places: on the magnetic \ndisk, in main memory, in the cache, and in an internal register\n\u2022 Once the increment takes place in the internal register, the \nvalue of A differs in the various storage systems. \nDownloaded from Ktunotes.in\n\n\nStorage management-Caching:\n\u2022 The value of A becomes the same only after the new value of A is \nwritten from the internal register back to the magnetic disk.\n\u2022 In a multitasking environment, where the CPU is switched back \nand forth among various processes ,if several processes wish t", "e of A is \nwritten from the internal register back to the magnetic disk.\n\u2022 In a multitasking environment, where the CPU is switched back \nand forth among various processes ,if several processes wish to \naccess A, then each of these processes will obtain the most recently \nupdated value of A.\n\u2022 In a multiprocessor environment where, in addition to maintaining \ninternal registers, each of the CPUs also contains a local cache .\n\u2022 In such an environment, a copy of A may exist simultaneously in \nseveral caches. \n\u2022 Since the various CPUs can all execute in parallel, we must make \nsure that an update to the value of A in one cache is immediately \nreflected in all other caches where A resides. \n\u2022 This situation is called cache coherency, and it is usually a \nhardware issue .\nDownloaded from Ktunotes.in", "he value of A in one cache is immediately \nreflected in all other caches where A resides. \n\u2022 This situation is called cache coherency, and it is usually a \nhardware issue .\nDownloaded from Ktunotes.in\n\n\nStorage management-Caching:\n\u2022 In a distributed environment, several copies (or replicas) of the \nsame file can be kept on different computers. \n\u2022 Since the various replicas may be accessed and updated \nconcurrently, some distributed systems ensure that, when a \nreplica is updated in one place, all other replicas are brought \nup to date as soon as possible\nDownloaded from Ktunotes.in\n\n\nI/O  Management\n\u2022 One of the purposes of an operating system is to hide the \npeculiarities of specific hardware devices from the user.\n\u2022 Every  operating systems has an I/O subsystem for managing \nits I/O devices.\nDownloaded from Ktunotes.in", "an operating system is to hide the \npeculiarities of specific hardware devices from the user.\n\u2022 Every  operating systems has an I/O subsystem for managing \nits I/O devices.\nDownloaded from Ktunotes.in\n\n\nProtection and Security\n\u2022 If a computer system has multiple users and allows the \nconcurrent execution of multiple processes, then access to data \nmust be regulated. \n\u2022 There must be mechanisms to ensure that files, memory \nsegments, CPU, and other resources can be operated on by \nonly those processes that have gained proper authorization \nfrom the operating system. \n\u2022 For example, memory-addressing hardware ensures that a \nprocess can execute only within its own address space. \n\u2022 The timer ensures that no process can gain control of the CPU \nwithout eventually relinquishing control. \nDownloaded from Ktunotes.in", "that a \nprocess can execute only within its own address space. \n\u2022 The timer ensures that no process can gain control of the CPU \nwithout eventually relinquishing control. \nDownloaded from Ktunotes.in\n\n\nProtection and Security\n\u2022 Protection  is any mechanism for controlling the access of \nprocesses  or users to the resources defined by a computer \nsystem. \n\u2022 A system can have adequate protection but still be prone to \nfailure and allow inappropriate access.\n\u2022 Job of security is to defend a system from external and internal \nattacks.\nDownloaded from Ktunotes.in\n\n\nProtection and Security\n\u2022 Attacks spread across a huge range and include \nviruses and worms, denial-of service  attacks (which \nuse all of a system\u2019s resources and so keep legitimate \nusers out of the system), identity theft, and theft of \nservice (unauthorized use of a system).\n\u2022  Prevention of some of these attacks is considered an \noperating-system function .\n\u2022 Protection and security require the system to be able \nto disting", "eft of \nservice (unauthorized use of a system).\n\u2022  Prevention of some of these attacks is considered an \noperating-system function .\n\u2022 Protection and security require the system to be able \nto distinguish among all its users.\n\u2022  Most operating systems maintain a list of user names \nand associated user identifiers (user IDs)\nDownloaded from Ktunotes.in\n\n\nProtection and Security\n\u2022 In some circumstances ,it is necessary  to distinguish among \nsets of users rather than individual users.\n\u2022 To accomplish this, define a group name and the set of users \nbelonging to that group. \n\u2022 Group functionality can be implemented as a system-wide list \nof group names and group identifiers.\n\u2022 A user can be in one or more groups, depending on operating-\nsystem design.\nDownloaded from Ktunotes.in\n\n\nComputer system can  be categorize according \nto the number of general-purpose processors \nused:\n\uf0d8Single-Processor Systems\n\uf0d8Multiprocessor Systems\n\uf0d8Clustered Systems\nDownloaded from Ktunotes.in", "s.in\n\n\nComputer system can  be categorize according \nto the number of general-purpose processors \nused:\n\uf0d8Single-Processor Systems\n\uf0d8Multiprocessor Systems\n\uf0d8Clustered Systems\nDownloaded from Ktunotes.in\n\n\nSingle-Processor Systems\n\u2022 On a single processor system, there is one main CPU capable of \nexecuting a general-purpose instruction set, including instructions \nfrom user processes. \n\u2022 Almost all single processor systems have other special-purpose \nprocessors like device-specific processors, such as disk, keyboard, \nand graphics controllers.\n\u2022 All of these special-purpose processors run a limited instruction set \nand do not run user processes. \n\u2022 Sometimes, they are managed by the operating system, in that the \noperating system sends them information about their next task and \nmonitors their status. \nDownloaded from Ktunotes.in", "r processes. \n\u2022 Sometimes, they are managed by the operating system, in that the \noperating system sends them information about their next task and \nmonitors their status. \nDownloaded from Ktunotes.in\n\n\nMultiprocessor Systems\n\u2022 Two or more processors in close communication, sharing the \ncomputer bus and sometimes the clock, memory, and  \nperipheral devices. \nMultiprocessor systems have three main advantages:\n1. Increased throughput\n\u2022 By increasing the number of processors, more work done in \nless time.\n\u2022 The speed-up ratio with N processors is not N, however; rather, \nit is less than N. \n\u2022 When multiple processors cooperate on a task, a certain amount \nof overhead is incurred in keeping all the parts working \ncorrectly. \n\u2022 Contention for shared resources also, lowers the expected gain \nfrom additional processors. \nDownloaded from Ktunotes.in", "amount \nof overhead is incurred in keeping all the parts working \ncorrectly. \n\u2022 Contention for shared resources also, lowers the expected gain \nfrom additional processors. \nDownloaded from Ktunotes.in\n\n\nMultiprocessor Systems\n2. Economy of scale\nMultiprocessor systems can cost less than equivalent multiple \nsingle processor systems, because they can share peripherals, mass \nstorage, and power supplies. \n3. Increased reliability\n If functions can be distributed properly among several processors, \nthen the failure of one processor will not halt the system, only slow \nit down. \nIf we have ten processors and one fails, then each of the remaining \nnine processors can pick up a share of the work of the failed \nprocessor. Thus, the entire system runs only 10 percent slower, \nrather than failing altogether.\nDownloaded from Ktunotes.in", "e remaining \nnine processors can pick up a share of the work of the failed \nprocessor. Thus, the entire system runs only 10 percent slower, \nrather than failing altogether.\nDownloaded from Ktunotes.in\n\n\nMultiprocessor Systems\nThe multiple-processor systems in use today are of two \ntypes: \nAsymmetric multiprocessing:\n\u2022 Each processor is assigned a specific task.\n\u2022 A boss processor controls the system; the other processors either \nlook to the boss for instruction or have predefined tasks.\n\u2022 This scheme defines a boss\u2013worker relationship.\n\u2022  The boss processor schedules and allocates work to the worker \nprocessors.\nDownloaded from Ktunotes.in\n\n\nMultiprocessor Systems\nSymmetric multiprocessing (SMP)\n\u2022 Each processor performs all tasks within the operating system.\n\u2022 All processors are peers; no boss\u2013worker relationship exists \nbetween processors. \n\u2022 Each processor has its own set of registers, as well as a private \nor local cache. \n\u2022 All processors share physical memory.\nDownloaded from Ktunotes.in", "rker relationship exists \nbetween processors. \n\u2022 Each processor has its own set of registers, as well as a private \nor local cache. \n\u2022 All processors share physical memory.\nDownloaded from Ktunotes.in\n\n\nMultiprocessor Systems\n\u2022 Multiprocessing adds CPUs to increase computing power.\n\u2022  Multiprocessor systems are termed as multicore when \nmultiple computing cores on a single chip.\n\u2022  They can be more efficient than multiple chips with single \ncores because on-chip communication is faster than between-\nchip communication. \n\u2022 One chip with multiple cores uses significantly less power \nthan multiple single-core chips.\nDownloaded from Ktunotes.in\n\n\nClustered Systems\n\u2022 A type of multiprocessor system is a clustered system, which \ngathers together multiple CPUs.\n\u2022  Clustered systems differ from the multiprocessor systems  in \nthat they are composed of two or more individual systems or \nnodes joined together.\n\u2022  Each node may be a single processor system or a multicore \nsystem.", "ms differ from the multiprocessor systems  in \nthat they are composed of two or more individual systems or \nnodes joined together.\n\u2022  Each node may be a single processor system or a multicore \nsystem. \n\u2022 Clustered computers share storage and are closely linked via a \nlocal-area network LAN or a faster interconnect.\n\u2022 Clustering is usually used to provide high-availability service.\nDownloaded from Ktunotes.in\n\n\nClustered Systems\n\u2022 Service will continue even if one or more systems in the \ncluster fail. \n\u2022 A layer of cluster software runs on the cluster nodes. \n\u2022 Each node can monitor one or more of the others (over the \nLAN). \n\u2022 If the monitored machine fails, the monitoring machine can \ntake ownership of its storage and restart the applications that \nwere running on the failed machine. \n\u2022 The users and clients of the applications see only a brief \ninterruption of service.\nDownloaded from Ktunotes.in", "f its storage and restart the applications that \nwere running on the failed machine. \n\u2022 The users and clients of the applications see only a brief \ninterruption of service.\nDownloaded from Ktunotes.in\n\n\nClustered Systems\nDownloaded from Ktunotes.in\n\n\nTypes of Operating System\n\u2022 Single User\n\u2022 Multi-user\n\u2022 Multi-tasking\n\u2022 Multiprocessing\n\u2022 Batch Processing\n\u2022 Real Time\n\u2022 Distributed Systems\nDownloaded from Ktunotes.in\n\n\nSingle User\nTWO TYPES: \n\u2022 Single user, single task \nDesigned to manage the computer so that one user \ncan effectively do one thing at a time. Example: The \nPalm OS for Palm handheld computers\n\u2022 Single user, multi tasking \nDesigned with a single user in mind but can deal \nwith many applications running at the same \ntime .Type of operating system most people use on \ntheir desktop and laptop computers today\nDownloaded from Ktunotes.in", "a single user in mind but can deal \nwith many applications running at the same \ntime .Type of operating system most people use on \ntheir desktop and laptop computers today\nDownloaded from Ktunotes.in\n\n\nMulti-user\n\u2022 Allows many different users to take advantage of the \ncomputer's resources simultaneously \n\u2022 Allows multiple users to access the computer system \nat the same time \n\u2022 Time Sharing system and Internet servers as the multi \nuser systems\nDownloaded from Ktunotes.in\n\n\nMulti-tasking\n\u2022 Allows more than one program to run concurrently. \n\u2022 The tasks share common processing resources, such \nas a CPU and main memory \n\u2022 In the process, only one CPU is involved, but it \nswitches from one program to another so quickly \nthat it gives the appearance of executing all the \nprograms at the same time.\nDownloaded from Ktunotes.in", "he process, only one CPU is involved, but it \nswitches from one program to another so quickly \nthat it gives the appearance of executing all the \nprograms at the same time.\nDownloaded from Ktunotes.in\n\n\nMULTIPROCESSING\n\u2022 Multiprocessing, in general, refers to the utilization \nof multiple CPUs in a single computer system \n\u2022 Enables several programs to run concurrently\n\u2022 The term also refers to the ability of a system to \nsupport more than one processor and/or the ability \nto allocate tasks between them \nDownloaded from Ktunotes.in\n\n\nMULTI PROCESSING(cont..)\nDownloaded from Ktunotes.in\n\n\nBatch Operating System\n\u2022 Batch Operating System: the First operating system of \nthe second-generation computer\u00a0is the batch \noperating system.\n\u2022  Batch operating system took the input on the punch \ncard. \n\u2022 Each punch card had the different form of data. System \nexecuted the jobs one by one in batch.\n\u2022  When one job from the batch executed, then the \nsecond job has taken from it and so on. \n\u2022 No need for user interaction.\nDownloaded from Ktunotes.in", ". System \nexecuted the jobs one by one in batch.\n\u2022  When one job from the batch executed, then the \nsecond job has taken from it and so on. \n\u2022 No need for user interaction.\nDownloaded from Ktunotes.in\n\n\nBatch Operating System(cont..)\nDownloaded from Ktunotes.in\n\n\nReal Time systems\n\u2022 In Real Time systems, each job carries a certain deadline \nwithin which the Job is supposed to be completed, \notherwise the huge loss will be there or even if the result \nis produced then it will be completely useless.\n\u2022 The Application of a Real Time system exists in the case \nof military applications, if you want to drop a missile \nthen the missile is supposed to be dropped with certain \nprecision.\nDownloaded from Ktunotes.in\n\n\nDistributed Operating System.\n\u2022 Distributed Means data is stored and \nprocessed on multiple locations. \n\u2022 When a data is stored on to the multiple \ncomputers, those are placed in different \nlocations.\nDownloaded from Ktunotes.in", ".\n\u2022 Distributed Means data is stored and \nprocessed on multiple locations. \n\u2022 When a data is stored on to the multiple \ncomputers, those are placed in different \nlocations.\nDownloaded from Ktunotes.in\n\n\nOperating-System Operations\n\u2022 Modern operating systems are interrupt driven. \n\u2022 If there are no processes to execute, no I/O devices to service, \nand no users to whom to respond, an operating system will sit \nquietly, waiting for something to happen. \n\u2022 Events are almost always signaled by the occurrence of an \ninterrupt or a trap. \n\u2022 A trap (or an exception) is a software-generated interrupt \ncaused either by an error (for example, division by zero or \ninvalid memory access) or by a specific request from a user \nprogram that an operating-system service be performed.\nDownloaded from Ktunotes.in", "ed either by an error (for example, division by zero or \ninvalid memory access) or by a specific request from a user \nprogram that an operating-system service be performed.\nDownloaded from Ktunotes.in\n\n\n\u2022Interrupts\u00a0are signals sent to the CPU by external devices, normally I/O devices. \nThey tell the CPU to stop its current activities and execute the appropriate part \nof the operating system.\nThere are three types of interrupts:\n\u2022Hardware Interrupts\u00a0 are generated by hardware devices to signal that they \nneed some attention from the OS. They may have just received some data (e.g., \nkeystrokes on the keyboard); or they have just completed a task which the \noperating system previous requested, such as transferring data between the \nhard drive and memory.\n\u2022Software Interrupts\u00a0are generated by programs when they want to request a\u00a0\nsystem call\u00a0to be performed by the operating system.\n\u2022Traps\u00a0are generated by the CPU itself to indicate that some error or condition \noccurred for which assistanc", "programs when they want to request a\u00a0\nsystem call\u00a0to be performed by the operating system.\n\u2022Traps\u00a0are generated by the CPU itself to indicate that some error or condition \noccurred for which assistance from the operating system is needed.\n\u2022For each type of interrupt, separate segments of code in the operating system \ndetermine what action should be taken.\n\u2022 An interrupt service routine (ISR) is provided to deal with the interrupt.\nDownloaded from Ktunotes.in\n\n\nDual-Mode Operation\n\u2022 Dual-mode operation allows OS to protect itself and \nother system components\n\u2022 User mode and kernel mode( also called supervisor \nmode, system mode, or privileged mode)\n\u2013 Mode bit provided by hardware(kernel (0) or user (1).)\n\u2022 Provides ability to distinguish when system is running user \ncode or kernel code\n\u2022 Some instructions designated as privileged, only executable in \nkernel mode\n\u2022 System call changes mode to kernel, return from call resets it \nto user\nDownloaded from Ktunotes.in", "code or kernel code\n\u2022 Some instructions designated as privileged, only executable in \nkernel mode\n\u2022 System call changes mode to kernel, return from call resets it \nto user\nDownloaded from Ktunotes.in\n\n\nDownloaded from Ktunotes.in\n\n\n\u2022 \u00a0If the user attempts to run privileged \ninstruction in user mode then it will treat \ninstruction as illegal and traps to OS. Some of \nthe privileged instructions are:\u00a0\n\u00a0\n\u2022 Handling Interrupts\n\u2022 To switch from user mode to kernel mode.\n\u2022 Input-Output management.\nDownloaded from Ktunotes.in\n\n\nTimer\n\u2022 We must ensure that the operating system maintains control \nover the CPU.\n\u2022 We cannot allow a user program to get stuck in an infinite \nloop or to fail to call system services and never return control \nto the operating system. \n\u2022 To accomplish this goal, we can use a timer.\n\u2022 A timer can be set to interrupt the computer after a specified \nperiod.\nDownloaded from Ktunotes.in", "and never return control \nto the operating system. \n\u2022 To accomplish this goal, we can use a timer.\n\u2022 A timer can be set to interrupt the computer after a specified \nperiod.\nDownloaded from Ktunotes.in\n\n\nSystem Calls\n\u2022 The mechanism used by an application program to request \nservice from the operating system.\n\u2022  System calls causes the processor to change mode (e.g. to \n\"supervisor mode\" or \"protected mode\"). \n\u2022 This allows the OS to perform restricted actions such as \naccessing hardware devices or the memory management unit.\nDownloaded from Ktunotes.in\n\n\nSystem Calls\n\u2022 Systems calls are the programming interface to the services \nprovided by the OS\n\u2022 Typically written in a high-level language (C or C++)\nDownloaded from Ktunotes.in\n\n\nApplication\nSystem Calls\nSystem Calls\n(OS functions)\nEach has a name/number, set of parameters\nApplication\n(a process, a\nrunning program)\n\u2026.\nKernel/OS\nOther kernel functions\nother kernel functions can be called by system calls\nSystem Call Interface\nDownloaded from Ktunotes.in", "set of parameters\nApplication\n(a process, a\nrunning program)\n\u2026.\nKernel/OS\nOther kernel functions\nother kernel functions can be called by system calls\nSystem Call Interface\nDownloaded from Ktunotes.in\n\n\n\u2022 System call sequence to copy the contents of one file to \nanother file\nExample of System Calls\nDownloaded from Ktunotes.in\n\n\nSystem Call Implementation and Calling\n\u2022\nTypically, \n\u2013 a number associated with each \nsystem call\n\u2013 Number used as an index to a \ntable: System Call table\n\u2013 Table keeps addresses of \nsystem calls (routines)\n\u2013 System call runs and returns\n\u2022\nCaller does not know system call \nimplementation\n\u2013 Just knows interface\nDownloaded from Ktunotes.in\n\n\nStandard C Library Example\n\u2022 C program invoking printf() library call, \nwhich calls the write() system call\nDownloaded from Ktunotes.in", "lementation\n\u2013 Just knows interface\nDownloaded from Ktunotes.in\n\n\nStandard C Library Example\n\u2022 C program invoking printf() library call, \nwhich calls the write() system call\nDownloaded from Ktunotes.in\n\n\nSystem Call Parameter Passing\n\u2022\nOften, more information is required than simply identity of desired system \ncall\n\u2013 Exact type and amount of information vary according to \nOS and call\n\u2022\nThree general methods used to pass parameters to the OS\n\u2013 Simplest:  pass the parameters in registers\n\u2022  In some cases, may be more parameters than registers\n\u2013 Parameters stored in a block, or table, in memory, and \naddress of block passed as a parameter in a register \n\u2022 This approach taken by Linux and Solaris\n\u2013 Parameters placed, or pushed, onto the stack by the \nprogram and popped off the stack by the operating system\n\u2013 Block and stack methods do not limit the number or length \nof parameters being passed\nDownloaded from Ktunotes.in", "hed, onto the stack by the \nprogram and popped off the stack by the operating system\n\u2013 Block and stack methods do not limit the number or length \nof parameters being passed\nDownloaded from Ktunotes.in\n\n\nPassing of parameters as a table.\nDownloaded from Ktunotes.in\n\n\nAccessing and executing System Calls\n\u2022\nSystem calls typically not accessed directly by  \nprograms\n\u2022\nMostly accessed by programs via a high-level \nApplication Program Interface (API) (i.e. a library) \nrather than direct system call use\n\u2022\nThree most common APIs are :\n\u2013 Win32 API for Windows, \n\u2013 POSIX API for POSIX-based systems \n(including virtually all versions of UNIX, \nLinux, and Mac OS X), \n\u2013 Java API for the Java virtual machine \n(JVM)\nAPI (std lib)\nProgram\nSys Calls\nRest of Kernel\nOS\nDownloaded from Ktunotes.in\n\n\nTypes of System Calls\n\uf06eProcess control\n\uf09fend, abort\n\uf09fload, execute\n\uf09fcreate process, terminate process\n\uf09fget process attributes, set process attributes\n\uf09fwait for time\n\uf09fwait event, signal event\n\uf09fallocate and free m", "ystem Calls\n\uf06eProcess control\n\uf09fend, abort\n\uf09fload, execute\n\uf09fcreate process, terminate process\n\uf09fget process attributes, set process attributes\n\uf09fwait for time\n\uf09fwait event, signal event\n\uf09fallocate and free memory\n\uf06eFile management\n\uf09fcreate file, delete file\n\uf09fopen, close file\n\uf09fread, write, reposition\n\uf09fget and set file attributes\nDownloaded from Ktunotes.in\n\n\nTypes of System Calls\n\uf06eDevice management\n\uf09frequest device, release device\n\uf09fread, write, reposition\n\uf09fget device attributes, set device attributes\n\uf09flogically attach or detach devices\n\uf06eInformation maintenance\n\uf09fget time or date, set time or date\n\uf09fget system data, set system data\n\uf09fget and set process, file, or device attributes\n\uf06eCommunications\n\uf09fcreate, delete communication connection\n\uf09fsend, receive messages\n\uf09ftransfer status information\n\uf09fattach and detach remote devices\nDownloaded from Ktunotes.in", ", file, or device attributes\n\uf06eCommunications\n\uf09fcreate, delete communication connection\n\uf09fsend, receive messages\n\uf09ftransfer status information\n\uf09fattach and detach remote devices\nDownloaded from Ktunotes.in\n\n\nImportant System Calls Used in OS\nwait()\nIn some systems, a process needs to wait for another process to complete its execution. This type \nof situation occurs when a parent process creates a child process, and the execution of the parent \nprocess remains suspended until its child process executes.\nThe suspension of the parent process automatically occurs with a wait() system call. When the child \nprocess ends execution, the control moves back to the parent process.\nfork()\nProcesses use this system call to create processes that are a copy of themselves. With the help of \nthis system Call parent process creates a child process, and the execution of the parent process will \nbe suspended till the child process executes.\nexec()\nThis system call runs when an executable file in the context of", "rent process creates a child process, and the execution of the parent process will \nbe suspended till the child process executes.\nexec()\nThis system call runs when an executable file in the context of an already running process that \nreplaces the older executable file. However, the original process identifier remains as a new process \nis not built, but stack, data, head, data, etc. are replaced by the new process.\nkill():\nThe kill() system call is used by OS to send a termination signal to a process that urges the process \nto exit. However, a kill system call does not necessarily mean killing the process and can have \nvarious meanings.\nexit():\nThe exit() system call is used to terminate program execution. Specially in the multi-threaded \nenvironment, this call defines that the thread execution is complete. The OS reclaims resources that \nwere used by the process after the use of exit() system call.\nDownloaded from Ktunotes.in", "hreaded \nenvironment, this call defines that the thread execution is complete. The OS reclaims resources that \nwere used by the process after the use of exit() system call.\nDownloaded from Ktunotes.in\n\n\nExamples of Windows and\nUnix System Calls \nDownloaded from Ktunotes.in\n\n\nOperating System Structures \n\u2022 Simple Structure\n\u2022 Layered Systems\n\u2022 Microkernels\n\u2022 Modular\nDownloaded from Ktunotes.in\n\n\nSimple Structure\n\u2022 Many operating systems do not have well-defined \nstructures. \n\u2022 Frequently, such systems started as small, simple, and \nlimited systems and then grew beyond their original \nscope. \n\u2022 MS-DOS is an example of such a system.\n\u2022  It was originally designed and implemented by a few \npeople who had no idea that it would become so popular.\n\u2022  It was written to provide the most functionality in the\n     least space, so it was not carefully divided into modules.\nDownloaded from Ktunotes.in", "who had no idea that it would become so popular.\n\u2022  It was written to provide the most functionality in the\n     least space, so it was not carefully divided into modules.\nDownloaded from Ktunotes.in\n\n\nDevice driver is a computer program that operates or controls a particular type of \ndevice that is attached to a computer.\nBIOS(Basic Input output system) in a PC stored on a ROM chip\nDownloaded from Ktunotes.in\n\n\nSimple Structure(cont..)\n\u2022 In MS-DOS, the interfaces and levels of functionality are not \nwell separated.\n\u2022 For instance, application programs are able to access the basic \nI/O routines to write directly to the display and disk drives. \nSuch freedom leaves MS-DOS vulnerable to errant (or \nmalicious) programs, causing entire system crashes when user \nprograms fail. \n\u2022 The Intel 8088 for which it was written provides no dual mode \nand no hardware protection, the designers of MS-DOS had no \nchoice but to leave the base hardware accessible.\nDownloaded from Ktunotes.in", "The Intel 8088 for which it was written provides no dual mode \nand no hardware protection, the designers of MS-DOS had no \nchoice but to leave the base hardware accessible.\nDownloaded from Ktunotes.in\n\n\nMonolithic Structure -- UNIX\n    UNIX \u2013 limited by hardware functionality, the original \nUNIX operating system had limited structuring.  The \nUNIX OS consists of two separable parts\n\u2013 Systems programs\n\u2013 The kernel\n\u2022 Consists of everything below the system-call \ninterface and above the physical hardware\n\u2022 Provides the file system, CPU scheduling, memory \nmanagement, and other operating-system functions; \na large number of functions for one level\nDownloaded from Ktunotes.in\n\n\nTraditional UNIX System Structure\nBeyond simple but not fully layered\nDownloaded from Ktunotes.in\n\n\nMonolithic Structure \u2013 UNIX(cont..)\n\u2022 This monolithic structure was difficult to \nimplement and maintain. \n\u2022 It had a distinct performance advantage, \nhowever: there is very little overhead in the \nsystem call interface or in communication \nwithin the kernel.\nDownloaded from Ktunotes.in", "ment and maintain. \n\u2022 It had a distinct performance advantage, \nhowever: there is very little overhead in the \nsystem call interface or in communication \nwithin the kernel.\nDownloaded from Ktunotes.in\n\n\nLayered Approach\n\u2022 In a layered approach, the operating system is divided into a \nnumber of layers (levels), each built on top of lower layers.  \nThe bottom layer (layer 0), is the hardware; the highest \n(layer N) is the user interface.\n\u2022 Each layer  uses functions (operations) and services of  \nlower-level layers ie Layer n+1 uses services (exclusively) \nsupported by layer n\n\u2022  Easier to extend and evolve.\nDownloaded from Ktunotes.in\n\n\nLayered Operating System\nDownloaded from Ktunotes.in\n\n\nLayered Operating System\nAdvantage:\nSimplicity of construction and debugging. \n\u2022 Each  layer uses functions (operations)and services of only \nlower-level layers. This approach simplifies debugging and \nsystem verification. \n\u2022 The first layer can be debugged without any concern for the \nrest of the sy", "ctions (operations)and services of only \nlower-level layers. This approach simplifies debugging and \nsystem verification. \n\u2022 The first layer can be debugged without any concern for the \nrest of the system, because, it uses only the basic hardware to \nimplement its functions.\n\u2022 Once the first layer is debugged, its correct functioning can be \nassumed while the second layer is debugged, and so on.\n\u2022  If an error is found during the debugging of a particular layer, \nthe error must be on that layer, because the layers below it are \nalready debugged. Thus, the design and implementation of the \nsystem are simplified.\nDownloaded from Ktunotes.in\n\n\nLayered Operating System\nDisadvantage\nIt is difficult to appropriately define the various layers.\n\u2022 Because a layer can use only lower-level layers, careful \nplanning is necessary.\n\u2022  For example, the device driver for the backing store must be \nat a lower level than the memory-management routines, \nbecause memory management requires the ability to use the \nbacking store.\nDownloaded from Ktunotes.in", "evice driver for the backing store must be \nat a lower level than the memory-management routines, \nbecause memory management requires the ability to use the \nbacking store.\nDownloaded from Ktunotes.in\n\n\nLayered Operating System\nThis structure is less efficient than other types.\n\u2022  For instance, when a user program executes an I/O operation, \nit executes a system call that is trapped to the I/O layer, which \ncalls the memory-management layer, which in turn calls the \nCPU-scheduling layer, which is then passed to the hardware. \n\u2022 At each layer, the parameters may be modified, data may need \nto be passed, and so on. Each layer adds overhead to the \nsystem call. The net result is a system call that takes longer \nthan does one on a non layered system.\nDownloaded from Ktunotes.in\n\n\nMicrokernel System Structure \n\u2022 We have already seen that as UNIX expanded, the kernel became \nlarge and difficult to manage. \n\u2022 In the mid-1980s, researchers at Carnegie Mellon University \ndeveloped an operating", "ystem Structure \n\u2022 We have already seen that as UNIX expanded, the kernel became \nlarge and difficult to manage. \n\u2022 In the mid-1980s, researchers at Carnegie Mellon University \ndeveloped an operating system called Mach that modularized the \nkernel using the microkernel approach.\n\u2022  This method structures the operating system by removing all \nnonessential components from the kernel and implementing \nthem as system and user-level programs. The result is a smaller \nkernel.\nDownloaded from Ktunotes.in\n\n\nMicrokernel System Structure (cont..)\nDownloaded from Ktunotes.in\n\n\n\u2022 The main function of the microkernel is to provide communication \nbetween the client program and the various services that are also \nrunning in user space. Communication is provided through message \npassing.\nBenefits:\n\u2022 One benefit of the microkernel approach is that it makes extending \nthe operating system easier. All new services are added to user space \nand consequently do not require modification of the kernel.\n\u2022 When", "enefit of the microkernel approach is that it makes extending \nthe operating system easier. All new services are added to user space \nand consequently do not require modification of the kernel.\n\u2022 When the kernel does have to be modified, the changes tend to be \nfewer, because the microkernel is a smaller kernel. The resulting \noperating system is easier to port from one hardware design to \nanother. \n\u2022 The microkernel also provides more security and reliability, since \nmost services are running as user\u2014rather than kernel\u2014 processes. If \na service fails, the rest of the operating system remains untouched.\nDownloaded from Ktunotes.in\n\n\nMicrokernel System Structure \n\u2022 Benefits:(In short)\n\u2013 Easier to extend a microkernel\n\u2013 Easier to port the operating system to new \narchitectures\n\u2013 More reliable (less code is running in kernel mode)\n\u2013 More secure\n\u2022 Demerit:\n\u2013 Performance overhead of user space to kernel space \ncommunication\nDownloaded from Ktunotes.in", "tem to new \narchitectures\n\u2013 More reliable (less code is running in kernel mode)\n\u2013 More secure\n\u2022 Demerit:\n\u2013 Performance overhead of user space to kernel space \ncommunication\nDownloaded from Ktunotes.in\n\n\nModular\n\u2022 Best current methodology for operating-system design \ninvolves using loadable kernel modules. \n\u2022 Here, the kernel has a set of core components and links in \nadditional services via modules, either at boot time or during \nrun time. \n\u2022 This type of design is common in modern implementations of \nUNIX, such as Solaris, Linux, and Mac OS X, as well as \nWindows.\nDownloaded from Ktunotes.in\n\n\nModular\n\u2022 Kernel provides core services while  other services are \nimplemented dynamically, as the kernel is running. \n\u2022 Resembles a layered system in that each kernel section has \ndefined, protected interfaces; but it is more flexible than a \nlayered system, because any module can call any other \nmodule.\n\u2022 The approach is also similar to the microkernel approach in \nthat the primary module has", "d interfaces; but it is more flexible than a \nlayered system, because any module can call any other \nmodule.\n\u2022 The approach is also similar to the microkernel approach in \nthat the primary module has only core functions; but it is more \nefficient, because modules do not need to invoke message \npassing in order to communicate.\nDownloaded from Ktunotes.in\n\n\nModular-Example :Solaris operating \nsystem structure\nDownloaded from Ktunotes.in\n\n\nModular-Example :Solaris operating system \nstructure\nThe Solaris operating system structure,  is organized around a \ncore kernel with seven types of loadable kernel modules:\n1. Scheduling classes\n2. File systems\n3. Loadable system calls\n4. Executable formats\n5. STREAMS modules\n6. Miscellaneous\n7. Device and bus drivers\nDownloaded from Ktunotes.in\n\n\nOperating System Services\n\u2022\nOperating systems provide an environment for execution of programs \nand services to programs and users\n\u2022\nOne set of operating-system services provides functions that are helpful \nt", "g System Services\n\u2022\nOperating systems provide an environment for execution of programs \nand services to programs and users\n\u2022\nOne set of operating-system services provides functions that are helpful \nto the user:\n\u2013 User interface - Almost all operating systems have a user interface \n(UI).\n\u2022 Varies between Command-Line (CLI), Graphics User \nInterface (GUI),   Batch\n\uf0d8One is a command-line interface (CLI), which uses text commands and a method for entering them (say, a keyboard \nfor typing in commands in a specific format with specific options). \n\uf0d8Another is a batch interface, in which commands and directives to control those commands are entered into files, \nand those files are executed. \n\uf0d8Most commonly, a graphical user interface (GUI) is used\n\u2013 Program execution - The system must be able to load a program \ninto memory and to run that program, end execution, either \nnormally or abnormally (indicating error)\n\u2013 I/O operations -  A running program may require I/O, which may \ninvolve a file or an I/O device\nDownloaded from Ktunotes.in", "program, end execution, either \nnormally or abnormally (indicating error)\n\u2013 I/O operations -  A running program may require I/O, which may \ninvolve a file or an I/O device\nDownloaded from Ktunotes.in\n\n\nOperating System Services (Cont.)\n\u2022\nOne set of operating-system services provides functions that are helpful to the \nuser (Cont.):\n\u2013 File-system manipulation -  The file system is of particular interest. \nPrograms need to read and write files and directories, create and delete \nthem, search them, list file Information, permission management.\n\u2013 Communications \u2013 Processes may exchange information, on the same \ncomputer or between computers over a network\n\u2022 Communications may be via shared memory or through message \npassing (packets moved by the OS)\n\u2013 Error detection \u2013 OS needs to be constantly aware of possible errors\n\u2022 May occur in the CPU and memory hardware, in I/O devices, in user \nprogram\n\u2022 For each type of error, OS should take the appropriate action to ensure \ncorrect and consisten", "y aware of possible errors\n\u2022 May occur in the CPU and memory hardware, in I/O devices, in user \nprogram\n\u2022 For each type of error, OS should take the appropriate action to ensure \ncorrect and consistent computing\n\u2022 Debugging facilities can greatly enhance the user\u2019s and programmer\u2019s \nabilities to efficiently use the system\nDownloaded from Ktunotes.in\n\n\nOperating System Services (Cont.)\n\u2022\nAnother set of OS functions exists for ensuring the efficient operation of the \nsystem itself via resource sharing\n\u2013 Resource allocation - When  multiple users or multiple jobs running \nconcurrently, resources must be allocated to each of them\n\u2022 Many types of resources -   CPU cycles, main memory, file storage, \nI/O devices.\n\u2013 Accounting - To keep track of which users use how much and what \nkinds of computer resources\n\u2013 Protection and security - The owners of information stored in a \nmultiuser or networked computer system may want to control use of that \ninformation, concurrent processes should not inte", "r resources\n\u2013 Protection and security - The owners of information stored in a \nmultiuser or networked computer system may want to control use of that \ninformation, concurrent processes should not interfere with each other\n\u2022 Protection involves ensuring that all access to system resources is \ncontrolled\n\u2022 Security of the system from outsiders requires user authentication, \nextends to defending external I/O devices from invalid access \nattempts\nDownloaded from Ktunotes.in\n\n\nA View of Operating System Services\nDownloaded from Ktunotes.in\n\n\nSystem Boot\n\u2022 The procedure of starting a computer by loading the kernel is \nknown as booting the system. \n\u2022 On most computer systems, a small piece of code known as \nthe bootstrap program or bootstrap loader locates the kernel, \nloads it into main memory, and starts its execution\n\u2022 . This program is in the form of read-only memory (ROM), \nbecause the RAM is in an unknown state at system startup.\n\u2022 All forms of ROM are also known as firmware\nDownloaded from Ktunotes.in", "xecution\n\u2022 . This program is in the form of read-only memory (ROM), \nbecause the RAM is in an unknown state at system startup.\n\u2022 All forms of ROM are also known as firmware\nDownloaded from Ktunotes.in\n\n\nSystem Boot Cont..\n\u2022 When power initialized on system, execution starts at a \nfixed memory location\n\u2013 Firmware ROM used to hold initial boot code\n\u2022 Operating system must be made available to hardware so \nhardware can start it\n\u2013 Small piece of code \u2013 bootstrap loader, stored in ROM or \nEPROM locates the kernel, loads it into memory, and starts it\n\u2013 Sometimes two-step process where boot block at fixed location \nloaded by ROM code, which loads bootstrap loader from disk\n\u2022 Common bootstrap loader, GRUB( is an example of an \nopen-source bootstrap program for Linux systems)  allows \nselection of kernel from multiple disks, versions, kernel \noptions\n\u2022 Kernel loads and system is then running\nDownloaded from Ktunotes.in", "f an \nopen-source bootstrap program for Linux systems)  allows \nselection of kernel from multiple disks, versions, kernel \noptions\n\u2022 Kernel loads and system is then running\nDownloaded from Ktunotes.in\n\n\nBooting Process\nDownloaded from Ktunotes.in\n\n\n\u2022 BIOS(Basic Input Output System) is very\u00a0first step\u00a0when you \npress power button on your CPU. BIOS is a\u00a0small \nfirmware\u00a0stored in ROM of mother board which \nis\u00a0manufacturer dependent code. The function of BIOS is, it \ninitializes some of the hardware on computer, checks integrity \nand finally it initializes first level boot loader .\n\u2022 Boot loader is a program which is called by BIOS and once \nagain\u00a0initializes boot related hardware\u00a0and finally boot loader \nis the one who exactly Knows(memory location) where \nthe\u00a0Kernel image is stored in secondary memory. It loads \nKernel image from secondary storage to RAM.\nDownloaded from Ktunotes.in"]